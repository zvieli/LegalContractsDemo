import "dotenv/config";
import pkg from "hardhat";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const { ethers, network } = pkg;
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function main() {
  console.log("üöÄ Starting Unified V7 + Merkle Evidence Deployment...");

  const [deployer, tenant] = await ethers.getSigners();
  console.log("üìù Deploying with deployer:", deployer.address, " tenant:", tenant.address);

  // Ensure frontend directories exist
  const frontendPublicContractsDir = path.resolve(__dirname, '..', 'front', 'public', 'utils', 'contracts');
  const frontendContractsDir = path.resolve(__dirname, '..', 'front', 'src', 'utils', 'contracts');
  
  try {
    fs.mkdirSync(frontendPublicContractsDir, { recursive: true });
    fs.mkdirSync(frontendContractsDir, { recursive: true });
  } catch (e) {
    console.error('‚ùå Could not create frontend directories:', e.message || e);
    throw e;
  }

  // === 1. Deploy Core Infrastructure ===
  console.log("\nüì¶ Deploying Core Infrastructure...");

  // Deploy MerkleEvidenceManager first (required by EnhancedRentContract)
  console.log("1Ô∏è‚É£ Deploying MerkleEvidenceManager...");
  const MerkleEvidenceManager = await ethers.getContractFactory('MerkleEvidenceManager');
  const merkleEvidenceManager = await MerkleEvidenceManager.deploy();
  await merkleEvidenceManager.waitForDeployment();
  const merkleAddress = await merkleEvidenceManager.getAddress();
  console.log("‚úÖ MerkleEvidenceManager deployed to:", merkleAddress);

  // Deploy ContractFactory
  console.log("2Ô∏è‚É£ Deploying ContractFactory...");
  const ContractFactory = await ethers.getContractFactory("ContractFactory");
  const contractFactory = await ContractFactory.deploy();
  await contractFactory.waitForDeployment();
  const factoryAddress = await contractFactory.getAddress();
  console.log("‚úÖ ContractFactory deployed to:", factoryAddress);

  // Deploy ArbitrationService
  console.log("3Ô∏è‚É£ Deploying ArbitrationService...");
  const ArbitrationService = await ethers.getContractFactory("ArbitrationService");
  const arbitrationService = await ArbitrationService.deploy();
  await arbitrationService.waitForDeployment();
  const arbitrationServiceAddress = await arbitrationService.getAddress();
  console.log("‚úÖ ArbitrationService deployed to:", arbitrationServiceAddress);

  // Deploy RecipientKeyRegistry
  console.log("4Ô∏è‚É£ Deploying RecipientKeyRegistry...");
  const RecipientKeyRegistry = await ethers.getContractFactory("RecipientKeyRegistry");
  const keyRegistry = await RecipientKeyRegistry.deploy();
  await keyRegistry.waitForDeployment();
  const keyRegistryAddress = await keyRegistry.getAddress();
  console.log("‚úÖ RecipientKeyRegistry deployed to:", keyRegistryAddress);

  // Deploy Arbitrator Oracle
  console.log("5Ô∏è‚É£ Deploying Arbitrator Oracle...");
  const Arbitrator = await ethers.getContractFactory("Arbitrator");
  const arbitrator = await Arbitrator.deploy(arbitrationServiceAddress);
  await arbitrator.waitForDeployment();
  const arbitratorAddress = await arbitrator.getAddress();
  console.log("‚úÖ Arbitrator deployed to:", arbitratorAddress);

  // === 2. Configure Contracts ===
  console.log("\nüîß Configuring Contracts...");

  // Set default arbitration service in factory
  try {
    await contractFactory.setDefaultArbitrationService(arbitrationServiceAddress, ethers.parseEther('0.5'));
    console.log("‚úÖ Factory configured with ArbitrationService");
  } catch (e) {
    console.warn("‚ö†Ô∏è Could not set arbitration service in factory:", e.message);
  }

  // Set Merkle evidence manager in factory
  try {
    await contractFactory.setMerkleEvidenceManager(merkleAddress);
    console.log("‚úÖ Factory configured with MerkleEvidenceManager");
  } catch (e) {
    console.warn("‚ö†Ô∏è Could not set Merkle evidence manager in factory:", e.message);
  }

  // Configure ArbitrationService
  try {
    await arbitrationService.setFactory(arbitratorAddress);
    console.log("‚úÖ ArbitrationService configured with Arbitrator");
  } catch (e) {
    console.warn("‚ö†Ô∏è Could not configure ArbitrationService:", e.message);
  }

  // === 3. Chainlink Price Feed Setup ===
  console.log("\nüîó Setting up Chainlink Price Feed...");
  let priceFeedAddress = "0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419"; // ETH/USD Mainnet
  
  if (network.name === "mainnet" || network.name === "hardhat") {
    priceFeedAddress = "0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419";
  } else if (network.name === "sepolia") {
    priceFeedAddress = "0x694AA1769357215DE4FAC081bf1f309aDC325306";
  }
  console.log(`‚úÖ Using Chainlink price feed: ${priceFeedAddress}`);

  // === 4. Test Merkle Evidence System ===
  console.log("\nüß™ Testing Merkle Evidence System...");
  
  const testBatch = {
    evidenceItems: [
      {
        caseId: 1,
        contentDigest: ethers.keccak256(ethers.toUtf8Bytes('Test evidence content')),
        cidHash: ethers.keccak256(ethers.toUtf8Bytes('QmTestCID123')),
        uploader: deployer.address,
        timestamp: Math.floor(Date.now() / 1000)
      }
    ]
  };

  // Encode evidence items for Merkle tree
  const leaves = testBatch.evidenceItems.map(item => {
    const encoded = ethers.AbiCoder.defaultAbiCoder().encode(
      ['uint256', 'bytes32', 'bytes32', 'address', 'uint256'],
      [item.caseId, item.contentDigest, item.cidHash, item.uploader, item.timestamp]
    );
    return ethers.keccak256(encoded);
  });

  const merkleRoot = leaves[0]; // Single item root
  
  // Submit test batch
  const batchTx = await merkleEvidenceManager.submitEvidenceBatch(merkleRoot, 1);
  const batchReceipt = await batchTx.wait();
  
  const batchEvent = batchReceipt.logs.find(log => 
    log.fragment && log.fragment.name === 'BatchCreated'
  );
  const batchId = batchEvent.args.batchId;
  console.log(`‚úÖ Test batch submitted (ID: ${batchId}, Gas: ${batchReceipt.gasUsed})`);

  // === 5. Sanity Checks ===
  console.log("\nüîç Running Sanity Checks...");
  
  try {
    const provider = ethers.provider || new ethers.JsonRpcProvider('http://127.0.0.1:8545');
    const factoryCode = await provider.getCode(factoryAddress);
    const merkleCode = await provider.getCode(merkleAddress);
    
    if (!factoryCode || factoryCode === '0x') {
      throw new Error(`No contract code at factory address ${factoryAddress}`);
    }
    if (!merkleCode || merkleCode === '0x') {
      throw new Error(`No contract code at Merkle manager address ${merkleAddress}`);
    }
    
    console.log(`‚úÖ Factory code: ${factoryCode.length / 2} bytes`);
    console.log(`‚úÖ Merkle manager code: ${merkleCode.length / 2} bytes`);
  } catch (err) {
    console.error('‚ùå Sanity check failed:', err.message);
    throw err;
  }
  try {
    fs.writeFileSync(publicDeploymentFile, JSON.stringify(deploymentData, null, 2));
    console.log("üíæ Deployment saved to frontend public:", publicDeploymentFile);
  } catch (e) {
    console.error('‚ùå Could not write ContractFactory.json to frontend public:', publicDeploymentFile, e.message || e);
    throw e;
  }

  // === SANITY CHECK: ensure the deployed factory has code on-chain ===
  try {
    const provider = ethers.provider || new ethers.JsonRpcProvider('http://127.0.0.1:8545');
    const code = await provider.getCode(factoryAddress);
    if (!code || code === '0x') {
      throw new Error(`No contract code found at factory address ${factoryAddress}. Make sure the chain you're deploying to matches the configured frontend network and the node is running.`);
    }
    console.log(`üîç Sanity check OK: factory code size ${code.length / 2} bytes`);
  } catch (err) {
    console.error('‚ùå Deploy sanity check failed:', err.message || err);
    throw err;
  }

  // === 2.5 Optionally deploy ArbitrationService and configure factory ===
  // By default we skip deploying ArbitrationService. Set DEPLOY_ARBITRATION=true to enable.
  // However, for local development we auto-enable deployment when the frontend
  // doesn't already contain an ArbitrationService address so the UI can prefill it.
  let arbitrationServiceAddress = null;
  let deployArbitration = String(process.env.DEPLOY_ARBITRATION || '').toLowerCase() === 'true';

  // If DEPLOY_ARBITRATION not explicitly set, enable on local networks when missing
  // from the frontend MockContracts.json so the UI can pick it up automatically.
  if (typeof process.env.DEPLOY_ARBITRATION === 'undefined') {
    try {
      const localNames = ['localhost', 'hardhat'];
      if (localNames.includes(network.name) || Number(process.env.CHAIN_ID) === 31337) {
        const mockContractsPath = path.join(frontendContractsDir, "MockContracts.json");
        let existingMock = {};
        if (fs.existsSync(mockContractsPath)) {
          try { existingMock = JSON.parse(fs.readFileSync(mockContractsPath, 'utf8')) || {}; } catch (e) { existingMock = {}; }
        }
        const hasArb = !!(existingMock && existingMock.contracts && existingMock.contracts.ArbitrationService);
        if (!hasArb) {
          deployArbitration = true;
          console.log('‚ÑπÔ∏è  DEPLOY_ARBITRATION not set - defaulting to true on local network to ensure ArbitrationService is available for the frontend');
        }
      }
    } catch (e) {
      console.warn('‚ö†Ô∏è  Could not determine whether to auto-deploy ArbitrationService:', e.message || e);
    }
  }

  // === 2.6 Deploy RecipientKeyRegistry ===
  console.log("üì¶ Deploying RecipientKeyRegistry...");
  let keyRegistryAddress = null;
  try {
    const RecipientKeyRegistry = await ethers.getContractFactory("RecipientKeyRegistry");
    const keyRegistry = await RecipientKeyRegistry.deploy();
    await keyRegistry.waitForDeployment();
    keyRegistryAddress = await keyRegistry.getAddress();
    console.log("‚úÖ RecipientKeyRegistry deployed to:", keyRegistryAddress);
  } catch (err) {
    console.error("‚ùå RecipientKeyRegistry deployment failed:", err.message || err);
    throw err;
  }

  if (deployArbitration) {
    console.log("üì¶ Deploying ArbitrationService...");
    try {
      const ArbitrationService = await ethers.getContractFactory("ArbitrationService");
      const arbitrationService = await ArbitrationService.deploy();
      await arbitrationService.waitForDeployment();
      arbitrationServiceAddress = await arbitrationService.getAddress();
      console.log("‚úÖ ArbitrationService deployed to:", arbitrationServiceAddress);

      // Deploy ArbitrationContractV2 (Chainlink Functions client)
      console.log("üì¶ Deploying ArbitrationContractV2 (Chainlink Functions client)...");
      // For local development, we'll use a mock router address (zero address)
      // In production, use the actual Chainlink Functions router for your network
      const mockRouterAddress = "0x0000000000000000000000000000000000000000"; 
      const ArbitrationContractV2 = await ethers.getContractFactory("ArbitrationContractV2");
      const arbitrationContractV2 = await ArbitrationContractV2.deploy(arbitrationServiceAddress, mockRouterAddress);
      await arbitrationContractV2.waitForDeployment();
      const arbitrationContractV2Address = await arbitrationContractV2.getAddress();
      console.log("‚úÖ ArbitrationContractV2 deployed to:", arbitrationContractV2Address);

      // Configure the ArbitrationService to trust the ArbitrationContractV2 as factory
      try {
        const tx2 = await arbitrationService.setFactory(arbitrationContractV2Address);
        await tx2.wait();
        console.log("üîß ArbitrationService.factory set to ArbitrationContractV2:", arbitrationContractV2Address);
      } catch (err) {
        console.warn("‚ö†Ô∏è  Could not set ArbitrationService.factory to ArbitrationContractV2:", err.message || err);
      }

      // Update the previously-written ContractFactory.json to include the service
      try {
        // Update the ContractFactory.json we wrote earlier (publicDeploymentFile)
        const deploymentFileContents = fs.readFileSync(publicDeploymentFile, 'utf8');
        const parsed = JSON.parse(deploymentFileContents);
        parsed.contracts = parsed.contracts || {};
        parsed.contracts.ArbitrationService = arbitrationServiceAddress;
        parsed.contracts.ArbitrationContractV2 = arbitrationContractV2Address;
        if (keyRegistryAddress) {
          parsed.contracts.RecipientKeyRegistry = keyRegistryAddress;
        }
        fs.writeFileSync(publicDeploymentFile, JSON.stringify(parsed, null, 2));
        console.log("üíæ Updated ContractFactory.json with ArbitrationService and ArbitrationContractV2 addresses");
      } catch (err) {
        console.warn("‚ö†Ô∏è  Could not update ContractFactory.json with ArbitrationService address:", err.message || err);
      }
      
      // Also merge the ArbitrationService address into MockContracts.json so the frontend
      // can automatically pick it up when using the local dev environment.
      try {
        const mockContractsPath = path.join(frontendContractsDir, "MockContracts.json");
        let existingMock = {};
        if (fs.existsSync(mockContractsPath)) {
          try { existingMock = JSON.parse(fs.readFileSync(mockContractsPath, 'utf8')) || {}; } catch (e) { existingMock = {}; }
        }
        existingMock.contracts = existingMock.contracts || {};
        existingMock.contracts.ArbitrationService = arbitrationServiceAddress;
        if (keyRegistryAddress) {
          existingMock.contracts.RecipientKeyRegistry = keyRegistryAddress;
        }
        existingMock.contracts.ArbitrationContractV2 = arbitrationContractV2Address;
        fs.writeFileSync(mockContractsPath, JSON.stringify(existingMock, null, 2));
        console.log('üíæ Updated MockContracts.json with ArbitrationService and ArbitrationContractV2 addresses');
      } catch (err) {
        console.warn('‚ö†Ô∏è  Could not update MockContracts.json with ArbitrationService address:', err.message || err);
      }
      // Configure factory default arbitration so newly created Rent contracts
      // receive the arbitrationService address at construction. This avoids
      // needing to call `setArbitrationService` on each template after deploy.
      try {
        const factoryInstance = await ethers.getContractAt('ContractFactory', factoryAddress, deployer);
        // Set factory default arbitration to the deployed service (owner only)
        try {
          const tx = await factoryInstance.setDefaultArbitrationService(arbitrationServiceAddress, 0);
          await tx.wait();
          console.log(`üîß Set ContractFactory.defaultArbitrationService -> ${arbitrationServiceAddress}`);
        } catch (err) {
          console.warn('‚ö†Ô∏è  Could not set default arbitration on factory (owner permissions?):', err.message || err);
        }
      } catch (err) {
        console.warn('‚ö†Ô∏è  Could not connect to ContractFactory to set default arbitration:', err.message || err);
      }
    } catch (err) {
      console.warn('‚ö†Ô∏è  ArbitrationService deploy failed:', err.message || err);
    }
  } else {
    console.log('‚ÑπÔ∏è  Skipping ArbitrationService deployment (set DEPLOY_ARBITRATION=true to enable)');
    // If we're on localhost and the frontend lacks an ArbitrationService entry, write
    // a placeholder note so the frontend knows to prompt the developer clearly.
    try {
      const mockContractsPath = path.join(frontendContractsDir, "MockContracts.json");
      let existingMock = {};
      if (fs.existsSync(mockContractsPath)) {
        try { existingMock = JSON.parse(fs.readFileSync(mockContractsPath, 'utf8')) || {}; } catch (e) { existingMock = {}; }
      }
      existingMock.contracts = existingMock.contracts || {};
      if (!existingMock.contracts.ArbitrationService) {
        // Use a clear sentinel value so the frontend can detect and prompt the dev
        existingMock.contracts.ArbitrationService = "MISSING_ARBITRATION_SERVICE";
        fs.writeFileSync(mockContractsPath, JSON.stringify(existingMock, null, 2));
        console.log('üíæ Wrote placeholder ArbitrationService=MISSING_ARBITRATION_SERVICE to MockContracts.json so frontend knows it is missing');
      }
    } catch (e) {
      console.warn('‚ö†Ô∏è  Could not write placeholder ArbitrationService to MockContracts.json:', e.message || e);
    }
  }

  // OracleArbitratorFunctions deployment removed in sweep

  // === 3. Copy ABIs ===
  console.log("üìÇ Copying ABI files to frontend...");

  const abiSourceDir = path.resolve(__dirname, '..', 'artifacts', 'contracts');
  // Scan the Hardhat artifacts/contracts directory and copy every contract artifact
  // This makes the deploy script resilient to added/removed contracts and ensures
  // the frontend has the exact ABIs produced by the current compile.
  let copiedCount = 0;
  let skippedCount = 0;

  const walkAndCopy = (dir) => {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const ent of entries) {
      const full = path.join(dir, ent.name);
      if (ent.isDirectory()) {
        // artifact subdirs typically correspond to source file paths (e.g. NDA)
        walkAndCopy(full);
      } else if (ent.isFile() && ent.name.endsWith('.json')) {
        // skip debug-only artifact files and any artifacts that live under
        // a `testing` or `test-mocks` source directory (these are test contracts)
        if (full.includes(`${path.sep}testing${path.sep}`) || full.includes(`${path.sep}test-mocks${path.sep}`) || ent.name.endsWith('.dbg.json')) {
          skippedCount++;
          console.log(`‚è≠ Skipping test/debug artifact: ${full}`);
          continue;
        }

        try {
          const artifact = JSON.parse(fs.readFileSync(full, 'utf8'));
          // If the artifact's contract name looks like a test (contains "test"), skip it
          if (artifact.contractName && /test/i.test(artifact.contractName)) {
            skippedCount++;
            console.log(`‚è≠ Skipping test artifact by name: ${artifact.contractName}`);
            continue;
          }
          // artifact.contractName is usually present; fall back to filename
          const contractName = artifact.contractName || path.basename(ent.name, '.json');
          // Some artifact JSONs are debug/interface-only and contain no bytecode.
          // Prefer the full `bytecode` when available, otherwise fall back to
          // `deployedBytecode`. If neither exists (interfaces/abstracts), write null.
          const chosenBytecode = (artifact.bytecode && artifact.bytecode.length > 2)
            ? artifact.bytecode
            : (artifact.deployedBytecode && artifact.deployedBytecode.length > 2)
              ? artifact.deployedBytecode
              : null;

          // Skip debug-only artifacts (hardhat sometimes produces .dbg JSON or
          // artifacts that clearly do not represent a deployable contract).
          // We treat an artifact with empty ABI as non-deployable and skip it.
          if (!artifact.abi || !Array.isArray(artifact.abi) || artifact.abi.length === 0) {
            // skip interface/debug artifacts
            skippedCount++;
            console.log(`‚è≠ Skipping ${contractName} (no ABI or interface-only artifact)`);
            continue;
          }

          const abiData = {
            abi: artifact.abi || [],
            contractName: contractName,
            bytecode: chosenBytecode,
          };

          const publicDest = path.join(frontendPublicContractsDir, `${contractName}ABI.json`);
          fs.writeFileSync(publicDest, JSON.stringify(abiData, null, 2));
          console.log(`‚úÖ Copied ${contractName} ABI to public`);
          copiedCount++;
        } catch (error) {
          console.error(`‚ùå Error copying artifact ${full}:`, error.message);
          skippedCount++;
        }
      }
    }
  };

  if (fs.existsSync(abiSourceDir)) {
    walkAndCopy(abiSourceDir);
  } else {
    console.warn('‚ö†Ô∏è  ABI source directory not found:', abiSourceDir);
    console.warn('‚ö†Ô∏è  Make sure you ran `npx hardhat compile` before deploying so artifacts exist.');
  }

  // === 4. Write MockContracts.json with deployed mock addresses and factory (no sample/demo contract) ===
  console.log("üíæ Writing MockContracts.json for frontend...");

    try {
      // Write MockContracts.json to public (primary)
      const publicMockContractsPath = path.join(frontendPublicContractsDir, "MockContracts.json");
      let existing = {};
      if (fs.existsSync(publicMockContractsPath)) {
        try { existing = JSON.parse(fs.readFileSync(publicMockContractsPath, 'utf8')) || {}; } catch (e) { existing = {}; }
      }

      existing.contracts = existing.contracts || {};
      if (mockPriceAddress) existing.contracts.MockPriceFeed = mockPriceAddress;
      existing.contracts.ContractFactory = existing.contracts.ContractFactory || factoryAddress;

      fs.writeFileSync(publicMockContractsPath, JSON.stringify(existing, null, 2));
      console.log("‚úÖ MockContracts.json written/updated to frontend public:", publicMockContractsPath);
      // Extra verification: print the file size and presence to help debugging when the frontend can't find it
      try {
        const stat = fs.statSync(publicMockContractsPath);
        console.log(`‚ÑπÔ∏è  Wrote MockContracts.json (${stat.size} bytes)`);
      } catch (stErr) {
        // ignore
      }
    } catch (err) {
      console.error("‚ö†Ô∏è  Could not write MockContracts.json to frontend:", err.message || err);
    }

  console.log(`üéâ Copied ${copiedCount} ABI files to ${frontendContractsDir}`);
  if (skippedCount > 0) {
    console.log(`‚ö†Ô∏è  Skipped ${skippedCount} contracts (not found)`);
  }

  console.log("‚úÖ Deployment & ABI copy finished successfully!");
}

main().catch((error) => {
  console.error("‚ùå Deployment failed:", error);
  process.exit(1);
});

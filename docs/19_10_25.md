

## High-level summary (one line)
Implement a secure server-side pipeline that collects full contract transaction/event history, combines it with user evidence, uploads the combined encrypted payload to Helia (producing a CID/URI), returns that reference to the frontend which will include it in the on-chain dispute/cancellation flow; plus a set of frontend UX and reliability improvements and optional Chainlink/LLM automation.

---

## Chronological work plan (steps, files, acceptance criteria, estimates)

### Step 1 — Server: contract-history collector + helper
- Goal: gather all on-chain logs and tx metadata for a contract (= the full history).
- Why first: server does the secure assembly; frontend relies on it.
- Files to add/edit:
  - Create `server/lib/collectHistory.js`
  - Possibly edit index.js to export a provider/helper if needed
- Key behavior:
  - Export async `collectContractHistory(contractAddress, { fromBlock = 0, toBlock = 'latest', includeTxData = false })`
  - Uses provider.getLogs with decoded ABI (use contract ABIs in contracts or `server/config/contracts`)
  - For each event include: event name, txHash, args (decoded), blockNumber, blockTimestamp, from, to, value (if available)
  - If `includeTxData`, fetch transaction details for important entries
- Acceptance:
  - Unit test: call `collectContractHistory` on a deployed local contract and assert it returns an array with decoded events including timestamps.
- Estimate: 2–4 hours

- Status: ✅ Completed (implemented `server/lib/collectHistory.js`; unit tests pending) — 2025-10-20

### Step 2 — Server: POST `/api/submit-appeal` endpoint (assemble + upload)
- Goal: receive `{ contractAddress, userEvidence, caseId? }`, collect history, build combined JSON, encrypt, upload to evidence endpoint/Helia, return `evidenceRef`
- Files to add/edit:
  - Create `server/routes/evidence.js` (new route file) and register in index.js or existing router
  - Create `server/lib/heliaUploader.js` (uploader helper with optional chunking/manifest)
  - Use existing `tools/admin/*` or `server/lib/crypto.js` for encryption with admin public key (server reads pubkey from env)
- Behavior:
  - Assemble combinedPayload:
    - metadata: contractAddress, caseId, collectedAt, submitter (if provided)
    - eventsContext: full history from Step 1
    - userEvidence: original text / CID string
  - If combinedPayload size > server-config threshold (configurable), chunk and produce manifest; otherwise upload single file
  - POST ciphertext to configured Evidence Endpoint or call Helia client and return `heliaUri` (preferred)
  - Save mapping in server DB or simple server-side mapping file (digest → heliaUri)
- Acceptance:
  - Calling `POST /api/submit-appeal` for contract with events returns JSON `{ evidenceRef: 'helia://<cid>' }`.
  - The uploaded Helia object (via preview endpoint in Step 3) contains `eventsContext` and `userEvidence`.
- Estimate: 4–8 hours

- Status: ✅ Implemented server-side components (route wired, `heliaUploader.js` and encryption helpers added). Integration and manifest/encryption QA pending — 2025-10-20

### Step 3 — Server: preview endpoint + decrypt helper
- Goal: allow admin/verified server callers or UI to preview decrypted content (or a safe snippet) from a ref (CID/digest) — used for debugging and tests.
- Files to add/edit:
  - Add to `server/routes/evidence.js` new handler `POST /api/preview-evidence` (accepts `{ ref }`)
  - Add `server/lib/decrypt.js` to run admin-side decryption (private key read from env in dev only)
- Behavior:
  - Resolve `ref` -> fetch object from Helia or evidence endpoint
  - If ciphertext JSON, decrypt using server private key (only allowed on server)
  - Return preview snippet (configurable max size)
- Acceptance:
  - `POST /api/preview-evidence` with a valid ref returns JSON with `previewText` containing `eventsContext` keys and userEvidence snippet.
- Estimate: 2–4 hours

- Status: ✅ Implemented `POST /api/preview-evidence` (admin-only) and ECIES wrapper; ensure `ADMIN_PRIV_KEY`/`ADMIN_PREVIEW_KEY` env vars are set for use — 2025-10-20

### Step 4 — Frontend: call server `submit-appeal` from ContractModal (flow change)
- Goal: replace direct client-side `uploadEvidence` usage in `startCancellationWithAppeal` / `submitDisputeForm` with server call to `POST /api/submit-appeal`.
- Files to edit:
  - ContractModal.jsx — change logic where evidence is uploaded; call server; use returned `evidenceRef` in on-chain call.
  - Optionally contractService.js — add helper `submitAppealToServer(...)` used by UI
- Behavior:
  - When user clicks Start Cancellation / Submit Dispute, frontend does:
    - call `POST /api/submit-appeal` with `contractAddress` and `userEvidence`
    - receive `evidenceRef` and call `ContractService.reportRentDispute(...)` or `startCancellationWithAppeal` with that ref
- Acceptance:
  - Manual: Submit appeal in UI → network shows `/api/submit-appeal` POST → returned `evidenceRef` used in on-chain transaction
- Estimate: 1–2 hours

### Step 5 — Frontend: CID-detection guard & small UX
- Goal: detect when user pasted a CID/URI and avoid re-uploading it; show reference type in UI.
- Files to edit:
  - contractService.js — add helper `isLikelyCid(ref)` (regex for helia://, ipfs://, /ipfs/, CID patterns).
  - AppealEvidenceList.jsx — display label "CID" vs "digest", keep Open/Copy buttons (Open only if CID)
  - ContractModal.jsx — small change if still using direct upload (but with server approach this is still useful)
- Behavior:
  - If the userEvidence is already a CID, send it to server as userEvidence; server will include it in combinedPayload without re-upload, or server can skip re-upload for CID payloads.
- Acceptance:
  - When user pastes `helia://<cid>`, server does not upload duplicate content; `appealEvidence` saved with type=`CID`.
- Estimate: 1–2 hours

### Step 6 — Durability & UI instrumentation for pending queue
- Goal: make pending queue survive browser restarts and enhance UI to show lastError/retry/remove.
- Files to edit:
  - contractService.js — change `_loadPendingQueue` / `_savePendingQueue` to use `localStorage` or IndexedDB (implement in localStorage for simplicity).
  - ContractModal.jsx — improve pending modal to show `lastError`, attempts, and provide Retry/Remove buttons, and refresh after Save Evidence
- Behavior:
  - Pending items survive reload/close; Retry tries immediate flush; Remove deletes item.
- Acceptance:
  - Enqueue a fake pending item, reload page — item still shows; Retry calls `retryPendingEvidence`.
- Estimate: 1–2 hours

### Step 7 — Server: Helia uploader with chunking and manifest
- Goal: robustly upload large combinedPayloads by chunking if necessary and produce manifest/manifest CID as canonical `evidenceRef`.
- Files to add/edit:
  - `server/lib/heliaUploader.js` (implement chunking, manifest creation)
  - Use this uploader in `server/routes/evidence.js`
- Behavior:
  - If combined payload > threshold (configurable), split into chunks, upload each chunk as file to Helia, create manifest JSON with chunk CIDs and metadata, upload manifest and return manifest CID/URI as `evidenceRef`.
  - If small, upload single file and return its CID.
- Acceptance:
  - For large payload (simulate), server returns a manifest `helia://<cid>` whose contents include list of chunk CIDs.
- Estimate: 3–6 hours (depends on Helia client code availability)

### Step 8 — Chainlink local integration & forwarder to LLM
- Goal: automate forwarding of combined evidence to LLM via Chainlink Functions or server->Chainlink request
- Files to add/edit:
  - `server/listeners/disputeForwarder.js` (listens for DisputeReported or for new entries in server DB)
  - Chainlink job spec files under `server/chainlink/` or `chainlink/jobs/`
  - Possibly an external adapter script if needed for Ollama
- Behavior:
  - On event, server or Chainlink job will fetch the Helia content (or use server preview), optionally decrypt, chunk/summarize, and call LLM (via Ollama or Chainlink Function)
  - Store verdict in server DB and optionally emit a UI notification or write resolution on-chain if workflow requires
- Acceptance:
  - Simulate a DisputeReported event locally, verify server/Chainlink logs show LLM call and response recorded
- Estimate: 1–3 days (depending on Chainlink setup & adapters)

### Step 9 — Tests + docs
- Goal: unit + integration tests and documentation for the flow and storage keys
- Files to add/edit:
  - Front tests: `front/src/services/__tests__/collectHistory.test.js`, `front/src/components/__tests__/AppealEvidenceList.test.jsx`
  - Server tests: `server/test/collectHistory.test.js`, `server/test/evidenceUpload.test.js`
  - Docs: `docs/EVIDENCE_HOSTING.md`, update README.md with endpoints `POST /api/submit-appeal`, `POST /api/preview-evidence` and storage keys
- Acceptance:
  - Unit tests pass locally; docs explain storage keys and security notes
- Estimate: 4–8 hours

### Step 10 — Optional: advanced chunk-summarize pipeline
- Goal: server pre-summarizes large payloads before sending to LLM; optionally store summary + manifest
- Files:
  - `server/lib/summarizer.js` (simple extractive summary or call to LLM for summarized chunks)
- Estimate: 1–2 days

---




## Security & operational notes (essential)
- Admin private key / decrypt key must be in env and never committed.
- Server must validate / rate-limit preview endpoint to avoid exposing decrypted payload to arbitrary callers.
- Since you require ALWAYS including the contract history, surface a privacy policy notice somewhere in admin docs or UX (you asked NOT to show opt-out in UI to users).
- Prefer server-side assembly (we chose server-side) — centralizes key usage & chunking logic.

---

## Engineering clarifications & mandatory constraints (developer checklist)
Below are concrete, non‑optional clarifications that must be followed when implementing the plan. They remove ambiguity that can cause security bugs or non‑portable code when using automatic code generation (Copilot/Copilots).

1) Encryption format and helper (SERVER)
  - Implement a single helper `server/lib/crypto.js` and export a clear API:

    ```js
    // server/lib/crypto.js
    export async function encryptWithAdminPubKey(plaintext) { /* uses RSA‑OAEP or x25519+AES‑GCM hybrid */ }
    export async function decryptWithAdminPrivKey(ciphertext) { /* admin only */ }
    ```

  - Chosen algorithm: use an explicit hybrid scheme (recommended): X25519/ECIES to derive symmetric key + AES‑GCM for bulk encryption, or RSA‑OAEP if your admin key is RSA. Document which one you pick in env and README; do NOT let Copilot invent the algorithm.

2) Manifest encryption & content (Helia uploads)
  - The manifest JSON (if used for chunking) MUST be encrypted before upload if it contains any metadata that is privacy‑sensitive. Default behavior: encrypt the manifest the same way as payloads. If you intentionally want an unencrypted manifest, that must be an explicit opt‑in and documented.
  - The manifest MAY include only chunk CIDs and non‑sensitive metadata (size, filename). If you include event payloads in the manifest, encrypt.

3) ABI sourcing and decoding (collectHistory)
  - `collectContractHistory` must not assume ABI is available for arbitrary addresses. Implement ABI lookup with fallback:

    ```js
    import contractAbis from '../config/contracts/index.js';
    const abi = contractAbis[contractAddress] || contractAbis.byName[contractName] || defaultAbi;
    ```

  - If ABI is unavailable, return raw logs plus decoded topics where possible and mark `decoded: false` for the entry to avoid silent failures.

4) Frontend UX: submission flow (frontend)
  - After calling `POST /api/submit-appeal`, the frontend must show a modal/loader 'Submitting evidence and contract history...' and disable the submit button until server responds. If the user closes the modal, persist intent (in UI state) and present outcome when done.

5) Pending queue storage limits (client)
  - `sessionStorage` is insufficient for durability; `localStorage` limited size (~5MB) is also risky for large payloads. Use IndexedDB for storing ciphertexts or large pending entries. If you choose `localStorage`, document that it's only for small metadata and refs, not ciphertext.

6) Chainlink integration (signing & jobs)
  - Define who signs Chainlink Functions requests. Options should be explicit in code comments/config:
    - Server signs the request (server wallet) and posts to Chainlink node via authenticated API; or
    - Smart contract emits event and Chainlink job triggers from the node (node signs/authorizes itself).
  - Add config options in `server/config/chainlink.js` for method and credentials; do NOT leave this unspecified.

7) LLM forwarding and decryption policy
  - Only the admin/backend (trusted server or on‑prem LLM) is allowed to decrypt ciphertext and forward plaintext to LLM. Public endpoints MUST NOT return plaintext.
  - Document in README: "Only the server with ADMIN_PRIV_KEY may decrypt and call the LLM. Preview endpoints are admin‑only and require x-api-key or similar auth."

8) Environment variables (explicit names)
  - Use explicit env var names and document them (example values):

    ```bash
    ADMIN_PUB_KEY="<PEM or base64 key>"   # public key (safe to store in env for server)
    ADMIN_PRIV_KEY="<PEM or base64 secret>" # private key (NEVER commit)
    EVIDENCE_ENDPOINT="https://evidence.example/submit-evidence"
    CHAINLINK_NODE_URL="http://127.0.0.1:6688"
    CHAINLINK_DON_ID="<DON ID>"
    PREVIEW_API_KEY="<secret for preview endpoint>"
    ```

9) Small improvements / developer hygiene (suggestions to implement)
  - Prefix new files with a version string if the repo contains legacy copies (e.g. `collectHistory.v1.js`) to avoid collisions.
  - Return manifest metadata (size, content type, filename) along with `evidenceRef` to help debugging.
  - Add a `POST /api/submit-appeal` header requirement `x-api-key` to prevent abuse; document this in README.
  - Add unit test for `preview` decrypt path that asserts the server reads `ADMIN_PRIV_KEY` from env.
  - Add a test case for `collectContractHistory` that includes a nested struct event to ensure decoding works.

---






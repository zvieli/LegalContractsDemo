מעולה 🙌 בוא נרכז את זה ממש בצורה מסודרת, לפי השלבים בפלואו של החוזים שלך (Report → Resolution Request → Oracle/AI → Enforcement), ונציין בכל שלב מה החורים האפשריים בלוגיקה.

---

# 🕳️ חורים לוגיים בפלואו של **ArbiTrust**

## 1. שלב ההתקשרות (Contract Initialization)

* **הגדרת צדדים**:

  * הנחה שכל צד = ארנק אחד. בפועל אין מנגנון שמונע **Sybil attack** (צד אחד שפותח כמה ארנקים ומעמיד פנים שהוא “צדדים שונים”).
  * אין וידוא שהארנק שייך לאדם אמיתי/חברה אמיתית → פער מול חוזה משפטי.

* **פיקדון (deposit)**:

  * הפיקדון לא בהכרח משקף את הנזק הפוטנציאלי (למשל ב־NDA, נזק של הדלפה יכול להיות הרבה יותר גדול).
  * אין מנגנון לעדכון גובה הפיקדון במהלך החוזה.

---

## 2. שלב דיווח ההפרה (Report Breach / Dispute)

* **Spam של דיווחים**:
 * **Spam של דיווחים**: ✓ (mitigations added: `disputeFee`, `minReportInterval`, `maxOpenReportsPerReporter`)

  * צד יכול להגיש אינסוף דיווחי הפרה כדי להקפיא את המערכת או להציק.
  * אין **עלות נוספת**/קנס על dispute שווא.

* **Timing**:

  * אין מגבלה מתי מותר לדווח (אפשר לדווח ישר אחרי שהחוזה נחתם).
  * אין מנגנון Deadlines (למשל, ב־NDA מותר לדווח רק עד X חודשים אחרי סיום ההתקשרות).

---

## 3. שלב בקשת הבוררות (Request Resolution)

* **מי מפעיל?**

  * רק אחד הצדדים יכול לקרוא לפונקציה, או שניהם?
  * מה אם צד אחד מסרב להפעיל אותה → המערכת נתקעת?

* **חוסר הגדרה לסינכרון**:

  * אם צד אחד מבקש resolution והשני מתעלם – האם זה נחשב הודאה באשמה?

---

## 4. שלב ההכרעה (Oracle / Arbitrator / AI)

* **NDA דו־צדדי = אין שובר שוויון**

  * אם אין צד שלישי מוסכם, הצבעה בין שני הצדדים תמיד תיקו.
  * זה “חור קריטי” בלוגיקה, אלא אם תמיד יש **Arbitrator חיצוני** (אנושי, Oracle או AI).

* **AI / Oracle לא מגיב** (timeout):

  * מה קורה אם ה־DON לא מחזיר תשובה בזמן?
  * הפתרון שלך כרגע = fallback דטרמיניסטי, אבל אם הוא תמיד אותו דבר (למשל “approve = true”), זה פותח פתח לניצול.
  * הוטמע local server + deterministic fallback (server-side wrapper + client fallback) — מפחית כשליות בבדיקות ובפיתוח ✓.
  * הערה: חשוב להגדיר מדיניות fallback זהירה בפרודקשן (fail-safe), לא להשאיר ברירת מחדל שמאפשרת ניצול.

* **אמינות AI**:

  * ה־AI מחזיר פסק דין בלי הסבר → קשה להאמין בו.
  * אין שקיפות לגבי dataset / bias → פתח לערעורים משפטיים מחוץ לבלוקצ’יין.

* **Finality**:

  * אין ערכאה שנייה לערעור. כל הכרעה היא סופית.
  * זה בסדר ל־MVP, אבל לא לחוזה אמיתי עם סכומים גדולים.
  * נוספו `appealWindowSeconds` ו־`finalizeEnforcement` — מאפשרים דחיית אכיפה וסקירה פנימית לפני תשלום סופי ✓.
  * זה עדיין לא תחליף לערכאות משפטיות חיצוניות.

---

## 5. שלב האכיפה (Enforcement)

* **ענישה לא פרופורציונלית**:

  * העונש תמיד מוגבל לפיקדון, גם אם הנזק בפועל עצום.
  * מצד שני, ייתכן שהנזק בפועל קטן בהרבה מהפיקדון, ועדיין נלקח כולו.

* **אין אכיפה “בעולם האמיתי”**:

  * גם אם הפיקדון נלקח, הצד שהפר יכול להמשיך להדליף/להשתמש במידע.
  * כלומר זה enforcement כלכלי בלבד, לא מניעתי.

---

## 6. תרחישים שלא מטופלים

* **שני הצדדים מפרים במקביל**: מי נחשב אשם ראשון?
* **Settlement מחוץ לשרשרת**: אין מנגנון שבו הצדדים מחליטים ביניהם בלי בורר.
* **Multi-party**: אין תמיכה ביותר משני צדדים (מהותי בחוזי שכירות למשל).

---


כן 🙂
כבר סידרנו את רוב ה"חורים הגדולים" בפלואו, אבל אם מסתכלים ממש בזכוכית מגדלת, יש עוד כמה נקודות לוגיות/מעשיות שיכולות להפוך לבעיות:

---

## 🕳️ חורים נוספים שעדיין קיימים

### 1. **שקיפות מול שני הצדדים**

* האם שני הצדדים יכולים לראות את *אותו הסט של נתונים* שנשלח ל־Oracle/AI?
* אם צד אחד שולח "הוכחות" שלא זמינות לשני → אין סימטריה.
* צריך לוודא ש־**input data שקוף לכל הצדדים** אחרת יש בעיית אמון.

---

### 2. **הוכחות / Evidence**

* כרגע ה־Oracle/AI מקבל קונטקסט, אבל אין מנגנון לאימות קריפטוגרפי של הראיות.
* לדוגמה: אם צד טוען ש־PDF הוא ההוכחה → אין אימות שהוא אותנטי ולא מזויף.
* בעולם חוזים חכמים נהוג לעבוד עם **hashes (evidenceHash)**, אבל לא ראיתי מנגנון חזק שמוודא שימוש בהם.
* הוספנו מנגנון commit→reveal: `evidenceHash` ב־report ו־`revealEvidence` שמוודא `keccak256(bytes(uri)) == evidenceHash` — כך שאומת שימוש בראיה דרך hash ✓.
* עדיין יש לשפר שקיפות ואחסון ראיות חיצוניות (אחסון מחוץ לשרשרת עם חתימה דיגיטלית אם צריך).

---

### 3. **בעיית תמריץ (Game Theory)**

* אם צד יודע שה־AI/Oracle חלש או נוטה לפסוק בצורה מסוימת, הוא יכול **לאיים**/לתמרן את הפלואו.
* למשל: אם fallback תמיד "מאשר" → משתלם להפר ולגרום ל־timeout.

---

### 4. **אי-ודאות משפטית**

* גם אם שני הצדדים הסכימו ל־smart contract, בבית משפט אמיתי הם יכולים לטעון ש־AI/Oracle לא קביל.
* זה לא חור קוד, אלא חור **במטרה**: חוזה חכם ≠ חוזה משפטי, אלא אם יש מנגנון bridging.

---

### 5. **Gas Costs ו־DoS Attack**

* אם dispute דורש קריאה ל־Chainlink Functions, אפשר לנסות "לשרוף" גז לצד השני.
* דמיין מתקפה: צד אחד מגיש dispute אחרי dispute וגורם ל־Oracle לקרוס או לעלות כסף למפעיל.
* אין מנגנון rate limiting.
* חלק מההגנות הוטמעו: `disputeFee`, `minReportInterval`, `maxOpenReportsPerReporter` מגבילים ספאם ואוספים תשלום נדרש להגשת דיווח ✓.

---

### 6. **שינוי תנאים בזמן ריצה**

* בחוזים רגילים לפעמים יש renegotiation (עדכון גובה פיקדון, שינוי סעיפים).
* אצלך זה חוזה סטטי → אם צריך שינוי → חייב לפרוס חוזה חדש → זה יוצר friction.

* הוספו מספר `onlyAdmin` setters: `setDisputeFee`, `setRevealWindowSeconds`, `setAppealWindowSeconds`, `setMinReportInterval`, `setMaxOpenReportsPerReporter` — מאפשר כוונון בזמן ריצה (חלקית) ✓.

---

### 7. **תלות ב־Oracle יחיד**

* גם אם זה Chainlink Functions, בסוף מדובר ב־**נקודת סמכות יחידה**.
* זה מתנגש עם הרעיון של ביזור.
* מה אם נרצה הצבעה של כמה Oracles?

---

### 8. **תלות בקונפיגורציה נכונה**

* `.env` ו־secrets מנוהלים Off-chain. אם מישהו שוכח להגדיר → המערכת נופלת ל־fallback.
* כלומר, **ברירת המחדל לא בטוחה** (fail-open במקום fail-safe).
* שונתה ברירת המחדל של ה־AI client והוספנו server-side wrapper + deterministic fallback כדי למנוע קריסה בטסטים; יש להגדיר מדיניות בטוחה לפרודקשן ✓.

---

### 9. **Concurrency / Re-entrancy**

* מה קורה אם יש שני disputes פתוחים במקביל?
* האם אפשר לקרוא שוב ל־`reportDispute` לפני שהראשון נסגר?
* אם כן → יש מצב ל־state conflict (מי נכנס ראשון ל־Oracle קובע).

* הוספנו `ReentrancyGuard` ו־`nonReentrant` על מסלולי תשלום/העברה כדי להקטין סיכון re-entrancy ✓.

---

### 10. **החוזה לא יודע על “נזק מצטבר”**

* ב־NDA למשל: ייתכן הפרה קטנה (דליפת מסמך אחד) ואח"כ עוד הפרות.
* אצלך החוזה רואה רק dispute בודד. אין זיכרון ל־multiple breaches.

* נוספו `offenderBreachCount` לצבירת הפרות מאושרות — מאפשר מעקב של הפרות מצטברות ✓.

---

⚖️ סיכום מרכזי של ה"חורים"

NDA בין שני צדדים → בוררות בהצבעה לא אפשרית (תמיד תיקו).

פיקדון ≠ נזק אמיתי (לא מכסה ולא פרופורציונלי).

Dispute spam: אין עלות נוספת לדיווחי סרק.

אין ערעורים: ההכרעה סופית גם אם ה־AI טעה.

AI/Oracle timeout: fallback עלול ליצור ניצול.

אין זהות אמיתית לצדדים: אפשרות ל־Sybil attack.

אין טיפול בהפרות הדדיות / Multi-party.

Enforcement כלכלי בלבד: לא מונע הפרה אמיתית בעולם האמיתי.
* שקיפות הנתונים ל־Oracle/AI.
* אימות קריפטוגרפי לראיות (evidence).
* תמריצים בעייתיים מול fallback / AI חלש.
* אי-ודאות משפטית (חוזה חכם ≠ חוזה מחייב).
* אפשרות DoS דרך spam של disputes.
* חוזה סטטי בלי renegotiation.
* תלות ב־Oracle יחיד ובקונפיגורציה נכונה.
* בעיות Concurrency אם נפתחים כמה disputes במקביל.
* אין ניהול של הפרות מצטברות.

---

* נוספו יכולות להוסיף צדדים (`addParty`) ושימוש בהצבעות בין כל ה־parties — תומך ב־multi-party בסיסית ✓


